{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang Di Web Imam Syafiih Biodata Mahasiswa Nama : Imam Syafiih NIM : 180411100043 Kelas : Komputasi Numerik 4B Dosen Pengampuh : Mulaab, S.Si, M.Kom Program Studi : Teknik Informatika","title":"Profil Mahasiswa"},{"location":"#selamat-datang-di-web-imam-syafiih","text":"","title":"Selamat Datang Di Web Imam Syafiih"},{"location":"#biodata-mahasiswa","text":"Nama : Imam Syafiih NIM : 180411100043 Kelas : Komputasi Numerik 4B Dosen Pengampuh : Mulaab, S.Si, M.Kom Program Studi : Teknik Informatika","title":"Biodata Mahasiswa"},{"location":"tugas1/","text":"Pendekatan Deret MacLaurin Deret MacLaurin DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan f'(x), f''(x), f'''(x) dan seterusnya yang kontinyu dalam interval I dengan a, x I maka untuk x disekitar a yaitu |x-a|< R , f(x) dapat diekspansi kedalam Deret Taylor. Dalam kasus khusus jika a=0 , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi : $$ f(x)=f(0)+\\frac{f^{1}(0)}{1 !} x+\\frac{f^{2}(0)}{2 !} x^{2}+\\frac{f^{3}(0)}{3 !} x^{3}+\\frac{f^{4}(0)}{4 !} x^{4} + ...+\\frac{f^{n}(0)}{n!}x^{n!} $$ Atau bisa dinyatakan dengan: $$ f(x)=\\sum_{n=0}^\\infty \\frac{f^{(n)}n(0)}{n!}x^{n} $$ Deret MacLaurin sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang sudah dihitung secara manual seperti nilai sin x, cos x , eksponensial, dll. Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin. Tugas Hitunglah e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001. Penyelesaian Fungsi awal exponen : $$ f(x) = e^{3x}\\ $$ Dapat juga didefinisikan dengan rumus : $$ e^{3x} = \\sum_{n=0}^\\infty \\frac{(3x)^n}{n!} = \\sum_{n=0}^\\infty (3)^n\\frac{x^n}{n!} $$ Deret turunan : $$ f(a)=e^{3x} $$ $$ f^{1}(a)=3e^{3x} $$ $$ f^{2}(a)=9e^{3x} $$ $$ f^{3}(a)=27e^{3x} $$ $$ f^{4}(a)=81e^{2x} $$ $$ ... $$ Berikut adalah penyelesaian untuk mencari nilai expansi : $$ f(x)=f(0)+\\frac{f^{1}(0)}{1 !} x+\\frac{f^{2}(0)}{2 !} x^{2}+\\frac{f^{3}(0)}{3 !} x^{3}+\\frac{f^{4}(0)}{4 !} x^{4} + ...+\\frac{f^{n}(0)}{n!}x^{n!} $$ nilai turunan pada tabel dimasukkan kedalam rumus sehingga didapatkan seperti ini : $$ f(x)=1+\\frac{3}{1 !} x+\\frac{9}{2 !} x^{2}+\\frac{27}{3 !} x^{3}+\\frac{81}{4 !} x^{4} + ...+\\frac{3^{n}}{n!} x^{n} $$ kemudian, nilai x diganti dengan 4 : $$ f(x)=1+\\frac{3}{1 !} 4+\\frac{9}{2 !} 4^{2}+\\frac{27}{3 !} 4^{3}+\\frac{81}{4 !} 4^{4} + ...+\\frac{3^{n}}{n!} 4^{n} $$ perhitungan diatas akan terus berulang hingga nilai selisih mendekati nilai error yang ditentukan yaitu kurang dari 0,001 Listing Program Script import math error = 0.001 def f(x): f_turunan = 1 current=i=0 iteration = True while iteration: old= current current += (f_turunan*(x**i))/math.factorial(i) print('f ke-', i,'=',current, 'Ea=', current-old ) if current-old < error: iteration = False else: f_turunan *=3 i +=1 f(4) Output f ke- 0 = 1.0 Ea= 1.0 f ke- 1 = 13.0 Ea= 12.0 f ke- 2 = 85.0 Ea= 72.0 f ke- 3 = 373.0 Ea= 288.0 f ke- 4 = 1237.0 Ea= 864.0 f ke- 5 = 3310.6 Ea= 2073.6 f ke- 6 = 7457.799999999999 Ea= 4147.199999999999 f ke- 7 = 14567.285714285714 Ea= 7109.4857142857145 f ke- 8 = 25231.514285714286 Ea= 10664.228571428572 f ke- 9 = 39450.485714285714 Ea= 14218.971428571429 f ke- 10 = 56513.25142857143 Ea= 17062.765714285713 f ke- 11 = 75127.17766233766 Ea= 18613.926233766237 f ke- 12 = 93741.1038961039 Ea= 18613.926233766237 f ke- 13 = 110923.18965034965 Ea= 17182.085754245752 f ke- 14 = 125650.69172541745 Ea= 14727.502075067794 f ke- 15 = 137432.69338547168 Ea= 11782.00166005423 f ke- 16 = 146269.19463051236 Ea= 8836.50124504068 f ke- 17 = 152506.7249211293 Ea= 6237.530290616938 f ke- 18 = 156665.07844820726 Ea= 4158.3535270779685 f ke- 19 = 159291.4069916249 Ea= 2626.3285434176505 f ke- 20 = 160867.20411767552 Ea= 1575.797126050602 f ke- 21 = 161767.65961827585 Ea= 900.4555006003357 f ke- 22 = 162258.81716405787 Ea= 491.1575457820145 f ke- 23 = 162515.07327490064 Ea= 256.25611084277625 f ke- 24 = 162643.20133032204 Ea= 128.12805542140268 f ke- 25 = 162704.7027969243 Ea= 61.501466602261644 f ke- 26 = 162733.08808920227 Ea= 28.385292277962435 f ke- 27 = 162745.70377465914 Ea= 12.61568545686896 f ke- 28 = 162751.1104969978 Ea= 5.406722338666441 f ke- 29 = 162753.3477614138 Ea= 2.237264416005928 f ke- 30 = 162754.2426671802 Ea= 0.8949057663849089 f ke- 31 = 162754.58908231556 Ea= 0.34641513536917046 f ke- 32 = 162754.71898799133 Ea= 0.12990567577071488 f ke- 33 = 162754.7662264189 Ea= 0.04723842756357044 f ke- 34 = 162754.7828988051 Ea= 0.016672386205755174 f ke- 35 = 162754.7886150518 Ea= 0.005716246698284522 f ke- 36 = 162754.79052046736 Ea= 0.0019054155563935637 f ke- 37 = 162754.79113843996 Ea= 0.0006179726042319089 Jadi, proses perulangan akan berhenti pada iterasi ke-37 karena selisih dari expansi yang dihasilkan mendekati nilai error yang ditentukan yaitu e < 0,001. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Tugas 1-MacLaurin"},{"location":"tugas1/#pendekatan-deret-maclaurin","text":"","title":"Pendekatan Deret MacLaurin"},{"location":"tugas1/#deret-maclaurin","text":"DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan f'(x), f''(x), f'''(x) dan seterusnya yang kontinyu dalam interval I dengan a, x I maka untuk x disekitar a yaitu |x-a|< R , f(x) dapat diekspansi kedalam Deret Taylor. Dalam kasus khusus jika a=0 , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi : $$ f(x)=f(0)+\\frac{f^{1}(0)}{1 !} x+\\frac{f^{2}(0)}{2 !} x^{2}+\\frac{f^{3}(0)}{3 !} x^{3}+\\frac{f^{4}(0)}{4 !} x^{4} + ...+\\frac{f^{n}(0)}{n!}x^{n!} $$ Atau bisa dinyatakan dengan: $$ f(x)=\\sum_{n=0}^\\infty \\frac{f^{(n)}n(0)}{n!}x^{n} $$ Deret MacLaurin sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang sudah dihitung secara manual seperti nilai sin x, cos x , eksponensial, dll. Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin.","title":"Deret MacLaurin"},{"location":"tugas1/#tugas","text":"Hitunglah e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001.","title":"Tugas"},{"location":"tugas1/#penyelesaian","text":"Fungsi awal exponen : $$ f(x) = e^{3x}\\ $$ Dapat juga didefinisikan dengan rumus : $$ e^{3x} = \\sum_{n=0}^\\infty \\frac{(3x)^n}{n!} = \\sum_{n=0}^\\infty (3)^n\\frac{x^n}{n!} $$ Deret turunan : $$ f(a)=e^{3x} $$ $$ f^{1}(a)=3e^{3x} $$ $$ f^{2}(a)=9e^{3x} $$ $$ f^{3}(a)=27e^{3x} $$ $$ f^{4}(a)=81e^{2x} $$ $$ ... $$ Berikut adalah penyelesaian untuk mencari nilai expansi : $$ f(x)=f(0)+\\frac{f^{1}(0)}{1 !} x+\\frac{f^{2}(0)}{2 !} x^{2}+\\frac{f^{3}(0)}{3 !} x^{3}+\\frac{f^{4}(0)}{4 !} x^{4} + ...+\\frac{f^{n}(0)}{n!}x^{n!} $$ nilai turunan pada tabel dimasukkan kedalam rumus sehingga didapatkan seperti ini : $$ f(x)=1+\\frac{3}{1 !} x+\\frac{9}{2 !} x^{2}+\\frac{27}{3 !} x^{3}+\\frac{81}{4 !} x^{4} + ...+\\frac{3^{n}}{n!} x^{n} $$ kemudian, nilai x diganti dengan 4 : $$ f(x)=1+\\frac{3}{1 !} 4+\\frac{9}{2 !} 4^{2}+\\frac{27}{3 !} 4^{3}+\\frac{81}{4 !} 4^{4} + ...+\\frac{3^{n}}{n!} 4^{n} $$ perhitungan diatas akan terus berulang hingga nilai selisih mendekati nilai error yang ditentukan yaitu kurang dari 0,001","title":"Penyelesaian"},{"location":"tugas1/#listing-program","text":"Script import math error = 0.001 def f(x): f_turunan = 1 current=i=0 iteration = True while iteration: old= current current += (f_turunan*(x**i))/math.factorial(i) print('f ke-', i,'=',current, 'Ea=', current-old ) if current-old < error: iteration = False else: f_turunan *=3 i +=1 f(4) Output f ke- 0 = 1.0 Ea= 1.0 f ke- 1 = 13.0 Ea= 12.0 f ke- 2 = 85.0 Ea= 72.0 f ke- 3 = 373.0 Ea= 288.0 f ke- 4 = 1237.0 Ea= 864.0 f ke- 5 = 3310.6 Ea= 2073.6 f ke- 6 = 7457.799999999999 Ea= 4147.199999999999 f ke- 7 = 14567.285714285714 Ea= 7109.4857142857145 f ke- 8 = 25231.514285714286 Ea= 10664.228571428572 f ke- 9 = 39450.485714285714 Ea= 14218.971428571429 f ke- 10 = 56513.25142857143 Ea= 17062.765714285713 f ke- 11 = 75127.17766233766 Ea= 18613.926233766237 f ke- 12 = 93741.1038961039 Ea= 18613.926233766237 f ke- 13 = 110923.18965034965 Ea= 17182.085754245752 f ke- 14 = 125650.69172541745 Ea= 14727.502075067794 f ke- 15 = 137432.69338547168 Ea= 11782.00166005423 f ke- 16 = 146269.19463051236 Ea= 8836.50124504068 f ke- 17 = 152506.7249211293 Ea= 6237.530290616938 f ke- 18 = 156665.07844820726 Ea= 4158.3535270779685 f ke- 19 = 159291.4069916249 Ea= 2626.3285434176505 f ke- 20 = 160867.20411767552 Ea= 1575.797126050602 f ke- 21 = 161767.65961827585 Ea= 900.4555006003357 f ke- 22 = 162258.81716405787 Ea= 491.1575457820145 f ke- 23 = 162515.07327490064 Ea= 256.25611084277625 f ke- 24 = 162643.20133032204 Ea= 128.12805542140268 f ke- 25 = 162704.7027969243 Ea= 61.501466602261644 f ke- 26 = 162733.08808920227 Ea= 28.385292277962435 f ke- 27 = 162745.70377465914 Ea= 12.61568545686896 f ke- 28 = 162751.1104969978 Ea= 5.406722338666441 f ke- 29 = 162753.3477614138 Ea= 2.237264416005928 f ke- 30 = 162754.2426671802 Ea= 0.8949057663849089 f ke- 31 = 162754.58908231556 Ea= 0.34641513536917046 f ke- 32 = 162754.71898799133 Ea= 0.12990567577071488 f ke- 33 = 162754.7662264189 Ea= 0.04723842756357044 f ke- 34 = 162754.7828988051 Ea= 0.016672386205755174 f ke- 35 = 162754.7886150518 Ea= 0.005716246698284522 f ke- 36 = 162754.79052046736 Ea= 0.0019054155563935637 f ke- 37 = 162754.79113843996 Ea= 0.0006179726042319089 Jadi, proses perulangan akan berhenti pada iterasi ke-37 karena selisih dari expansi yang dihasilkan mendekati nilai error yang ditentukan yaitu e < 0,001. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Listing Program"},{"location":"tugas2/","text":"Numerical Solution of Algebraic and Transcendental Equation 1. Mencari akar dengan cara Bisection Metode bisection adalah algoritma pencarian akar pada sebuah interval. Interval tersebut membagi dua bagian lalu memilih bagian mana yang mengandung akar dan bagian yang tidak mengandung akar dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh akar persamaan atau mendekati akar persamaan. Metode ini berlaku ketika ingin memecahkan persamaan dengan merupakan fungsi kontinyu. def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) output 1.9999999985098835 2. Mencari akar dengan cara Newton-Rapshon Metode Newton-Raphson adalah metode pencarian akar suatu fungsi dengan pendekatan satu titik, dimana fungsi mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal, semakin dekat titik awal yang kita pilih dengan akar sebenarnya maka semakin cepat konvergen ke akarnya. def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) output Found solution after 4 iterations. 1.9999847409781035 3. Mencari akar dengan cara Secant Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi harus memiliki turunan ., sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu, muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik dan . def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) output 2.0000003178913373 4. Mencari akar dengan cara Regulasi Falsi Metode Regular Falsi adalah panduan konsep Metode Bagi-Dua dan Metode Secant dimana menggunakan konsep Metode Bagi-Dua karena dimulai dengan pemilihan dua titik awal dan sedemikian sehingga dan berlawanan tanda atau . Kemudian menggunakan konsep Metode Secant yaitu dengan menarik garis dari titik dan sedemikian sehingga garis berpotongan pada sumbu \u2013 dan memotong kurva atau grafik fungsi pada titik dan . Sehingga Metode Regular Falsi ini akan menghasilkan titik potong pada sumbu- yaitu yang merupakan calon akar dan tetap berada dalam interval . Metode ini kemudian berlanjut dengan menghasilkan berturut-turut interval yang semuanya berisi akar . error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) output x = 2.000000000174259","title":"Tugas 2-Linier"},{"location":"tugas2/#numerical-solution-of-algebraic-and-transcendental-equation","text":"","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"tugas2/#1-mencari-akar-dengan-cara-bisection","text":"Metode bisection adalah algoritma pencarian akar pada sebuah interval. Interval tersebut membagi dua bagian lalu memilih bagian mana yang mengandung akar dan bagian yang tidak mengandung akar dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh akar persamaan atau mendekati akar persamaan. Metode ini berlaku ketika ingin memecahkan persamaan dengan merupakan fungsi kontinyu. def bisection(f,a,b,N): if f(a)*f(b) >= 0: print(\"Bisection method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = (a_n + b_n)/2 f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Bisection method fails.\") return None return (a_n + b_n)/2 f = lambda x: x**2 - 5*x + 6 approx_phi = bisection(f,1,2.3,25) print(approx_phi) output 1.9999999985098835","title":"1. Mencari akar dengan cara Bisection"},{"location":"tugas2/#2-mencari-akar-dengan-cara-newton-rapshon","text":"Metode Newton-Raphson adalah metode pencarian akar suatu fungsi dengan pendekatan satu titik, dimana fungsi mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal, semakin dekat titik awal yang kita pilih dengan akar sebenarnya maka semakin cepat konvergen ke akarnya. def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) output Found solution after 4 iterations. 1.9999847409781035","title":"2. Mencari akar dengan cara Newton-Rapshon"},{"location":"tugas2/#3-mencari-akar-dengan-cara-secant","text":"Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi harus memiliki turunan ., sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu, muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik dan . def secant(f,a,b,N): if f(a)*f(b) >= 0: print(\"Secant method fails.\") return None a_n = a b_n = b for n in range(1,N+1): m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) f_m_n = f(m_n) if f(a_n)*f_m_n < 0: a_n = a_n b_n = m_n elif f(b_n)*f_m_n < 0: a_n = m_n b_n = b_n elif f_m_n == 0: print(\"Found exact solution.\") return m_n else: print(\"Secant method fails.\") return None return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n)) p = lambda x: x**2 - 5*x + 6 approx = secant(p,1,2.4,20) print(approx) output 2.0000003178913373","title":"3. Mencari akar dengan cara Secant"},{"location":"tugas2/#4-mencari-akar-dengan-cara-regulasi-falsi","text":"Metode Regular Falsi adalah panduan konsep Metode Bagi-Dua dan Metode Secant dimana menggunakan konsep Metode Bagi-Dua karena dimulai dengan pemilihan dua titik awal dan sedemikian sehingga dan berlawanan tanda atau . Kemudian menggunakan konsep Metode Secant yaitu dengan menarik garis dari titik dan sedemikian sehingga garis berpotongan pada sumbu \u2013 dan memotong kurva atau grafik fungsi pada titik dan . Sehingga Metode Regular Falsi ini akan menghasilkan titik potong pada sumbu- yaitu yang merupakan calon akar dan tetap berada dalam interval . Metode ini kemudian berlanjut dengan menghasilkan berturut-turut interval yang semuanya berisi akar . error = 0.01 a = 0 b = 2.1 def f(x): return x**2 - 5*x + 6 def regulasi_falsi(a,b): i=0 max_iter = 50 iteration = True while iteration and i < max_iter: if f(a)*f(b) < 0: x = (a*abs(f(b)) + b*abs(f(a))) / (abs(f(a)) + abs(f(b))) if f(a)*f(x) < 0: b = x if f(x)*f(b) < 0: a = x if abs(a-b) < error: iteration = False else: i+=1 else: print('tidak di temukan akar') print('x =', x) regulasi_falsi(a,b) output x = 2.000000000174259","title":"4. Mencari akar dengan cara Regulasi Falsi"},{"location":"tugas3/","text":"Eliminasi Gauss Jordan \u00b6 Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan \u00b6 \u00b6 Listing Program \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u00b6 Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program \u00b6 from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel \u00b6 Listing Program \u00b6 def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Tugas 3-Eliminasi"},{"location":"tugas3/#eliminasi-gauss-jordan","text":"Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan\u00b6"},{"location":"tugas3/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan\u00b6"},{"location":"tugas3/#_1","text":"","title":"\u00b6"},{"location":"tugas3/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program\u00b6"},{"location":"tugas3/#eliminasi-gauss-jacobi","text":"Metode IterasiJacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi\u00b6"},{"location":"tugas3/#listing-program_1","text":"from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program\u00b6"},{"location":"tugas3/#program-gauss-seidel","text":"","title":"Program Gauss Seidel\u00b6"},{"location":"tugas3/#listing-program_2","text":"def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) print(x) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3. Sekian dan Terima Kasih","title":"Listing Program\u00b6"},{"location":"tugas4/","text":"METODE INTEGRASI ROMBERG \u00b6 A. Pengertian \u00b6 Integrasi Romberg merupakan teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( Richardson's extrapolation ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( error tolerance ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode trapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi dan fungsi transeden. Pada proses integrasi Romberg, mula-mula kita hitung kuadratur dengan lebar langkah h dan 2h. Defisini kuadratur adalah Untuk menurunkan galat hampiran integral dari O(h2) menjadi O(h2n + 2) dapat digunakan ekstrapolasi Richardson seperti dinyatakan dalam teorema : jika didefinisikan barisan kuadratur {I(i,j) : i >= j dimana j =1, 2, 3, ....} untuk hampiran integral f(x) pada [a, b] sebagai: I (i, 1) = Ti \u2013 1. i \u2265 1 ( barisan aturan trapezium majemuk) I (i, 2) = Si \u2013 1. i \u2265 2 (barisan aturan Simpson majemuk) I (i, 3) = Bi \u2013 1. i \u2265 3 (barisan aturan Boole majemuk) Maka integrasi romberg untuk meningkatkan keakuratan hampiran integral dapat di tulis sebagai B. Code Program \u00b6 import numpy as np def trapezcomp(f, a, b, n): \"\"\" Composite trapezoidal function integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound n: number of panels to create between ``a`` and ``b`` \"\"\" # Initialization h = (b - a) / n x = a # Composite rule In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): \"\"\" Romberg integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound p: number of rows in the Romberg table \"\"\" I = np.zeros((p, p)) for k in range(0, p): # Composite trapezoidal rule for 2^k panels I[k, 0] = trapezcomp(f, a, b, 2**k) # Romberg recursive formula for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) print(I[k, 0:k+1]) # display intermediate results return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(solution) # 1.00000000814 C. Output \u00b6 Microsoft Windows [Version 10.0.18362.657] (c) 2019 Microsoft Corporation. All rights reserved. C:\\Kuliah\\KomputasiNumerik>python romberg.py [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] 1.0000000081440203","title":"Tugas 4-Integrasi"},{"location":"tugas4/#metode-integrasi-romberg","text":"","title":"METODE INTEGRASI ROMBERG\u00b6"},{"location":"tugas4/#a-pengertian","text":"Integrasi Romberg merupakan teknik yang digunakan dalam integrasi numerik untuk menganalisis kasus dimana fungsi yang akan diintegrasikan tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan untuk mengembangkan skema yang efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson ( Richardson's extrapolation ), yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat. Teknik ini bersifat rekursif dan dapat digunakan untuk menghasilkan sebuah perkiraan integral dalam batas toleransi kesalahan ( error tolerance ) yang sudah ditentukan terlebih dahulu. Metode ini digunakan untuk memperbaiki hasil pendekatan integrasi metode trapesium, karena kesalahan metode trapesium \u201ccukup\u201d besar untuk polinom untuk polinom pangkat tinggi dan fungsi transeden. Pada proses integrasi Romberg, mula-mula kita hitung kuadratur dengan lebar langkah h dan 2h. Defisini kuadratur adalah Untuk menurunkan galat hampiran integral dari O(h2) menjadi O(h2n + 2) dapat digunakan ekstrapolasi Richardson seperti dinyatakan dalam teorema : jika didefinisikan barisan kuadratur {I(i,j) : i >= j dimana j =1, 2, 3, ....} untuk hampiran integral f(x) pada [a, b] sebagai: I (i, 1) = Ti \u2013 1. i \u2265 1 ( barisan aturan trapezium majemuk) I (i, 2) = Si \u2013 1. i \u2265 2 (barisan aturan Simpson majemuk) I (i, 3) = Bi \u2013 1. i \u2265 3 (barisan aturan Boole majemuk) Maka integrasi romberg untuk meningkatkan keakuratan hampiran integral dapat di tulis sebagai","title":"A. Pengertian\u00b6"},{"location":"tugas4/#b-code-program","text":"import numpy as np def trapezcomp(f, a, b, n): \"\"\" Composite trapezoidal function integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound n: number of panels to create between ``a`` and ``b`` \"\"\" # Initialization h = (b - a) / n x = a # Composite rule In = f(a) for k in range(1, n): x = x + h In += 2*f(x) return (In + f(b))*h*0.5 def romberg(f, a, b, p): \"\"\" Romberg integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound p: number of rows in the Romberg table \"\"\" I = np.zeros((p, p)) for k in range(0, p): # Composite trapezoidal rule for 2^k panels I[k, 0] = trapezcomp(f, a, b, 2**k) # Romberg recursive formula for j in range(0, k): I[k, j+1] = (4**(j+1) * I[k, j] - I[k-1, j]) / (4**(j+1) - 1) print(I[k, 0:k+1]) # display intermediate results return I if __name__ == '__main__': def func(x): return np.sin(x) p_rows = 4 I = romberg(func, 0, np.pi/2, p_rows) solution = I[p_rows-1, p_rows-1] print(solution) # 1.00000000814","title":"B. Code Program\u00b6"},{"location":"tugas4/#c-output","text":"Microsoft Windows [Version 10.0.18362.657] (c) 2019 Microsoft Corporation. All rights reserved. C:\\Kuliah\\KomputasiNumerik>python romberg.py [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] 1.0000000081440203","title":"C. Output\u00b6"},{"location":"tugas5/","text":"Richardson Extrapolation Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Teori Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc. Contoh Program from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): '''Richardson extrapolation method for numerical calculation of first derivative ''' k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('>>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<<') print(\"=======================================================================\") print('f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5') print(\"=======================================================================\") print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print(\"=======================================================================\") print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) Hasil Running >>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<< ======================================================================= f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 ======================================================================= -0.91250000000000530687 ======================================================================= diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 >>>","title":"Tugas 5-Richardson"},{"location":"tugas5/#richardson-extrapolation","text":"Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa.","title":"Richardson Extrapolation"},{"location":"tugas5/#teori","text":"Dalam rumus : ( f (x + h) - f (x - h) ) / (2 h) untuk nilai h yang sangat kecil, dua fungsi evaluasi f (x + h) dan f (x - h) akan menjadi kira-kira sama, dan oleh karena itu pembatalan subtraktif akan terjadi. Oleh karena itu, tidak disarankan untuk menggunakan nilai h yang semakin kecil. Kita dapat mencoba untuk memperkirakan nilai tepat e dengan perkiraan a(h) . Dalam hal ini, e adalah turunan dari f (1) (x) dan perkiraannya adalah ( h ) = (f (x + h) - f (x - h)) / (2 h) . Misalkan sekarang bahwa kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e = a(h) + K h n + o(h n ) Apabila menggunakan h / 2 : e = a(h/2) + K (h/2)n + o((h/2)n) = a(h/2) + K/2n h n + o(h n ) Mengalikan kedua ekspresi ini dengan 2 n dan mengurangi hasil persamaan pertama 2n e \u2212 e = 2na(h/2) \u2212 a(h) + K/2n h n \u2212 K h n + o(h n ) Perhatikan bahwa istilah h n dibatalkan dan kita dibiarkan dengan (2n \u2212 1)e = 2na(h/2) \u2212 a(h) + o(h n ) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk Knh n . Dapat kita tulis dengan : K1 = \u22121/6 f(3)(x)h 2 , etc.","title":"Teori"},{"location":"tugas5/#contoh-program","text":"from math import * def zeros(n,m): Z=[] for i in range(n): Z.append([0]*m) return Z def D(Func,a,h): return (Func(a+h)-Func(a-h))/(2*h) def Richardson_dif(func,a): '''Richardson extrapolation method for numerical calculation of first derivative ''' k=9 L=zeros(k,k) for I in range(k): L[I][0]=D(func,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('>>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<<') print(\"=======================================================================\") print('f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5') print(\"=======================================================================\") print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print(\"=======================================================================\") print('diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3))","title":"Contoh Program"},{"location":"tugas5/#hasil-running","text":">>>>>>>>>>>>>>>>>>>>>>> DIFERENSIASI NUMERIK DARI <<<<<<<<<<<<<<<<<<<<< ======================================================================= f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 ======================================================================= -0.91250000000000530687 ======================================================================= diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 >>>","title":"Hasil Running"},{"location":"tugas6/","text":"Methode Euler \u200b Dalam matematika dan ilmu komputasi , metode Euler (juga disebut metode forward Euler ) adalah prosedur numerik orde pertama untuk menyelesaikan persamaan diferensial biasa (ODE) dengan nilai awal yang diberikan. Ini adalah metode eksplisit paling dasar untuk integrasi numerik persamaan diferensial biasa dan merupakan metode Runge-Kutta paling sederhana. Metode Euler dinamai Leonhard Euler , yang memperlakukannya dalam bukunya Institutionum calculi integralis (diterbitkan 1768-1870). [ 1] \u200b Metode Euler adalah metode urutan pertama, yang berarti bahwa kesalahan lokal (kesalahan per langkah) sebanding dengan kuadrat ukuran langkah, dan kesalahan global (kesalahan pada waktu tertentu) sebanding dengan ukuran langkah. Metode Euler sering berfungsi sebagai dasar untuk membangun metode yang lebih kompleks, misalnya, metode prediktor-korektor . Contoh soal Buatlah program untuk menyelesaikan persamaan differensial biasa berikut dengan menggunakan metode Euler! Untuk menentukan y(1.01), y(1.02) dan y(1.03). Code Program dengan Python print(\"f(x,y)=1+x^2\") print(\"yi+1 = y1 + hf(xi+yi)\") x1 = float(input(\"Masukkan x1= \")) x2 = float(input(\"Masukkan x2= \")) h = 1.01-x1 #Langsung saya atur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n=4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = -4 hasil = xi y=0 for i in range(n): print(\"hasil dari y\"+str(i)+\"= \"+ str(hasil)) hasil = xi + h*(1+(x1+y)**2) y+=h xi=hasil pada bagian pertama terdapat variable x1 adalah x awal dan x2 merupakan x akhir. karena di soal terdapat nx=3 yaitu x0=1, x1=1,01, x3=1,02 x2=1,03 maka h= xn-x0/n, hasilnya h = 0.01. xi adalah hasil awal yang kemudian akan dimasukkan pada prosess iterasi. Karena rumus eurel adalah y1 = y0 +h(f(x,y)) maka rumus barunya adalah y1=y0+h(1+x^2). variable y digunakan untuk penambahan nilai x agar selalu bertambah 0.01. <script type=\"text/x-mathjax-config\"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} }); </script> <script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>","title":"Tugas 6-Tugas Pemrograman"},{"location":"tugas6/#methode-euler","text":"\u200b Dalam matematika dan ilmu komputasi , metode Euler (juga disebut metode forward Euler ) adalah prosedur numerik orde pertama untuk menyelesaikan persamaan diferensial biasa (ODE) dengan nilai awal yang diberikan. Ini adalah metode eksplisit paling dasar untuk integrasi numerik persamaan diferensial biasa dan merupakan metode Runge-Kutta paling sederhana. Metode Euler dinamai Leonhard Euler , yang memperlakukannya dalam bukunya Institutionum calculi integralis (diterbitkan 1768-1870). [ 1] \u200b Metode Euler adalah metode urutan pertama, yang berarti bahwa kesalahan lokal (kesalahan per langkah) sebanding dengan kuadrat ukuran langkah, dan kesalahan global (kesalahan pada waktu tertentu) sebanding dengan ukuran langkah. Metode Euler sering berfungsi sebagai dasar untuk membangun metode yang lebih kompleks, misalnya, metode prediktor-korektor .","title":"Methode Euler"},{"location":"tugas6/#contoh-soal","text":"Buatlah program untuk menyelesaikan persamaan differensial biasa berikut dengan menggunakan metode Euler! Untuk menentukan y(1.01), y(1.02) dan y(1.03).","title":"Contoh soal"},{"location":"tugas6/#code-program-dengan-python","text":"print(\"f(x,y)=1+x^2\") print(\"yi+1 = y1 + hf(xi+yi)\") x1 = float(input(\"Masukkan x1= \")) x2 = float(input(\"Masukkan x2= \")) h = 1.01-x1 #Langsung saya atur sendiri karena yang dicari f(x,y) nilai x-nya=1.01 n=4 #jumlah x ada 4 yaitu 1, 1.01, 1.02, 1.03 xi = -4 hasil = xi y=0 for i in range(n): print(\"hasil dari y\"+str(i)+\"= \"+ str(hasil)) hasil = xi + h*(1+(x1+y)**2) y+=h xi=hasil pada bagian pertama terdapat variable x1 adalah x awal dan x2 merupakan x akhir. karena di soal terdapat nx=3 yaitu x0=1, x1=1,01, x3=1,02 x2=1,03 maka h= xn-x0/n, hasilnya h = 0.01. xi adalah hasil awal yang kemudian akan dimasukkan pada prosess iterasi. Karena rumus eurel adalah y1 = y0 +h(f(x,y)) maka rumus barunya adalah y1=y0+h(1+x^2). variable y digunakan untuk penambahan nilai x agar selalu bertambah 0.01. <script type=\"text/x-mathjax-config\"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} }); </script> <script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\"> </script>","title":"Code Program dengan Python"},{"location":"tugas7/","text":"Metode dan Simulasi Monte Carlo \u00b6 Metode Monte Carlo \u00b6 Metode Monte Carlo adalah algoritma kom put asi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit, terutama integral multidimensi dengan syarat dan batasan yang rumit Melihat dari cara kerjanya metode Monte Carlo merupakan metode yang memberikan segala kemungkinan nilai dari suatu variabel. Metode Monte Carlo merupakan metode yang memanfaatkan strong law of large number dalam melakukan perhitungan, artinya semakin banyak variabel acak yang digunakan akan semakin baik pula pendekatan nilai eksaknya Algoritma dan contoh metode monte carlo \u00b6 Probabilitas pelemparan coin Ganda Dari teori peluang akan muncul: MM \u00ce \u00bc MB atau BM \u00ce \u00bd BB \u00ce \u00bc Dengan metode Monte Carlo dapatkan tingkat ketelitian sampai 0.01 untuk menyelesaikan kasus tersebut\u2026. Untuk mendapatkan ketelitian sampai 0,01 maka harus dilakukan pelemparan sebanyak 1000 (N_total) kali. Dari hasil pelemparan catat keluarnya angka-angka: P(MM) = N(MM)/N_total P(MB) = N(MB)/N_total P(BB) = N(BB)/N_total ALGORITHMA \u00b6 a. Bangkitkan nilai 0/1 sebanyak 1000 kali (N=1000) dengan cara: n1 =(int)rand()%2 dan n2 =(int)rand()%2 b. Klasifikasi Jika n1=0 dan n2=0, maka MM=MM+1 Jika n1=0 dan n2=1 atau n1=1 dan n2=0 maka MB=MB+1 Jika n1=1 dan n2=1, maka BB=BB+1 c. Hitung probabilitas MM dengan cara N(MM)/N dan probabilitas untuk nilai MB serta BB 2.Menghitung Nilai Integral dengan monte carlo Luas area dicari = yang berwarna atau daerah dibawah garis fungsi f(x) = 2x Dengan dasar pemikiran tersebut diperoleh suatu perbandingan: BIla kita melakukan pelemparan coin sebanyak N kali, dan coin jatuh di bawah garis f(x) =2x sebanyak M kali. Maka: tugas programing \u00b6 implemenasi metode carlo dalam python \u00b6 from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N=2500 def func(x): return (4-x**2)**0.5 area = [] for i in range(N): xrand = np.zeros(N) for i in range(len(xrand)): xrand[i] = random.uniform(a,b) integral = 0.0 for i in range(N): integral+=func(xrand[i]) jawab = (b-a)/float(N)*integral area.append(jawab) plt.title(\"Hasil phi\") plt.hist(area,bins = 30, ec = 'black') plt.xlabel(\"Area\") plt.show() hasil running \u00b6 from scipy import random import numpy as np a = -1 b = 1 N=100 xrand=np.zeros(N) yrand=np.zeros(N) zrand=np.zeros(N) integral=0.0 for i in range(4): for i in range(len(xrand)): xrand[i]=random.uniform(a,b) for i in range(len(yrand)): yrand[i]=random.uniform(a,b) for i in range(len(zrand)): zrand[i]=random.uniform(a,b) def func(x,y,z): return (x**2)+(y**2)+(z**2) for i in range(N): integral+=func(xrand[i],yrand[i],zrand[i]) jawab=(b-a)/float(N)*integral print(\"jawab: \",jawab) hasil running \u00b6 jawab: 7.941487167529855","title":"Tugas 7-Metode Monte Carlo"},{"location":"tugas7/#metode-dan-simulasi-monte-carlo","text":"","title":"Metode dan Simulasi Monte Carlo\u00b6"},{"location":"tugas7/#metode-monte-carlo","text":"Metode Monte Carlo adalah algoritma kom put asi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit, terutama integral multidimensi dengan syarat dan batasan yang rumit Melihat dari cara kerjanya metode Monte Carlo merupakan metode yang memberikan segala kemungkinan nilai dari suatu variabel. Metode Monte Carlo merupakan metode yang memanfaatkan strong law of large number dalam melakukan perhitungan, artinya semakin banyak variabel acak yang digunakan akan semakin baik pula pendekatan nilai eksaknya","title":"Metode Monte Carlo\u00b6"},{"location":"tugas7/#algoritma-dan-contoh-metode-monte-carlo","text":"Probabilitas pelemparan coin Ganda Dari teori peluang akan muncul: MM \u00ce \u00bc MB atau BM \u00ce \u00bd BB \u00ce \u00bc Dengan metode Monte Carlo dapatkan tingkat ketelitian sampai 0.01 untuk menyelesaikan kasus tersebut\u2026. Untuk mendapatkan ketelitian sampai 0,01 maka harus dilakukan pelemparan sebanyak 1000 (N_total) kali. Dari hasil pelemparan catat keluarnya angka-angka: P(MM) = N(MM)/N_total P(MB) = N(MB)/N_total P(BB) = N(BB)/N_total","title":"Algoritma dan contoh metode monte carlo\u00b6"},{"location":"tugas7/#algorithma","text":"a. Bangkitkan nilai 0/1 sebanyak 1000 kali (N=1000) dengan cara: n1 =(int)rand()%2 dan n2 =(int)rand()%2 b. Klasifikasi Jika n1=0 dan n2=0, maka MM=MM+1 Jika n1=0 dan n2=1 atau n1=1 dan n2=0 maka MB=MB+1 Jika n1=1 dan n2=1, maka BB=BB+1 c. Hitung probabilitas MM dengan cara N(MM)/N dan probabilitas untuk nilai MB serta BB 2.Menghitung Nilai Integral dengan monte carlo Luas area dicari = yang berwarna atau daerah dibawah garis fungsi f(x) = 2x Dengan dasar pemikiran tersebut diperoleh suatu perbandingan: BIla kita melakukan pelemparan coin sebanyak N kali, dan coin jatuh di bawah garis f(x) =2x sebanyak M kali. Maka:","title":"ALGORITHMA\u00b6"},{"location":"tugas7/#tugas-programing","text":"","title":"tugas programing\u00b6"},{"location":"tugas7/#implemenasi-metode-carlo-dalam-python","text":"from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N=2500 def func(x): return (4-x**2)**0.5 area = [] for i in range(N): xrand = np.zeros(N) for i in range(len(xrand)): xrand[i] = random.uniform(a,b) integral = 0.0 for i in range(N): integral+=func(xrand[i]) jawab = (b-a)/float(N)*integral area.append(jawab) plt.title(\"Hasil phi\") plt.hist(area,bins = 30, ec = 'black') plt.xlabel(\"Area\") plt.show()","title":"implemenasi metode carlo dalam python\u00b6"},{"location":"tugas7/#hasil-running","text":"from scipy import random import numpy as np a = -1 b = 1 N=100 xrand=np.zeros(N) yrand=np.zeros(N) zrand=np.zeros(N) integral=0.0 for i in range(4): for i in range(len(xrand)): xrand[i]=random.uniform(a,b) for i in range(len(yrand)): yrand[i]=random.uniform(a,b) for i in range(len(zrand)): zrand[i]=random.uniform(a,b) def func(x,y,z): return (x**2)+(y**2)+(z**2) for i in range(N): integral+=func(xrand[i],yrand[i],zrand[i]) jawab=(b-a)/float(N)*integral print(\"jawab: \",jawab)","title":"hasil running\u00b6"},{"location":"tugas7/#hasil-running_1","text":"jawab: 7.941487167529855","title":"hasil running\u00b6"}]}